require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const express = require('express');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = process.env.ADMIN_ID;
const PLATEGA_API_KEY = process.env.PLATEGA_API_KEY;
const PLATEGA_SHOP_ID = process.env.PLATEGA_SHOP_ID;
const PORT = process.env.PORT || 5000;

if (!BOT_TOKEN || !ADMIN_ID || !PLATEGA_API_KEY || !PLATEGA_SHOP_ID) {
  console.error('‚ùå –ù–µ –∑–∞–¥–∞–Ω—ã –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: BOT_TOKEN, ADMIN_ID, PLATEGA_API_KEY, PLATEGA_SHOP_ID');
  process.exit(1);
}

const bot = new TelegramBot(BOT_TOKEN, { polling: true });
const app = express();
app.use(express.json({ limit: '200kb' }));

// ---------- –•—Ä–∞–Ω–∏–ª–∏—â–µ ----------
const DATA_FILE = path.join(__dirname, 'data.json');
function loadData() {
  if (fs.existsSync(DATA_FILE)) {
    try { return JSON.parse(fs.readFileSync(DATA_FILE, 'utf8')); }
    catch { return { payments: {}, users: {} }; }
  }
  return { payments: {}, users: {} };
}
function saveData(data) {
  try { fs.writeFileSync(DATA_FILE, JSON.stringify(data, null, 2)); }
  catch (e) { console.error('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ data.json:', e.message); }
}
let dataStore = loadData();
const userStates = {};

const IMAGES = {
  MAIN: './attached_assets/pick spt_1759573098998.jpg',
  HELP: './attached_assets/pick help (1)_1759573098998.jpg',
  FAQ: './attached_assets/picksher_1759573098998.jpg'
};

// ---------- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ----------
function sendMainMenu(chatId) {
  const msg = `‚ùáÔ∏è *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Blesk !* ‚ùáÔ∏è

*‚ùóÔ∏è–í–ê–ñ–ù–û‚ùóÔ∏è*
–ü–µ—Ä–µ–¥ –ø–æ–∫—É–ø–∫–æ–π —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –∞–∫–∫–∞—É–Ω—Ç Spotify –Ω–µ —Å–æ—Å—Ç–æ—è–ª –≤ —Å–µ–º–µ–π–Ω–æ–º –ø–ª–∞–Ω–µ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≥–æ–¥.
–ï—Å–ª–∏ –Ω–µ —É–≤–µ—Ä–µ–Ω—ã ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Å–∞–ø–ø–æ—Ä—Ç!`;
  const keyboard = {
    inline_keyboard: [
      [{ text: 'üí≥ –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É (169 —Ä—É–±–ª–µ–π)', callback_data: 'buy' }],
      [{ text: 'üí¨ –°–∞–ø–ø–æ—Ä—Ç', callback_data: 'support' }],
      [{ text: '‚ùì FAQ', callback_data: 'faq' }]
    ]
  };
  if (fs.existsSync(IMAGES.MAIN))
    bot.sendPhoto(chatId, IMAGES.MAIN, { caption: msg, parse_mode: 'Markdown', reply_markup: keyboard });
  else bot.sendMessage(chatId, msg, { parse_mode: 'Markdown', reply_markup: keyboard });
}

bot.onText(/\/start/, msg => sendMainMenu(msg.chat.id));

// ---------- Callback –∫–Ω–æ–ø–∫–∏ ----------
bot.on('callback_query', async query => {
  const chatId = query.message.chat.id;
  const data = query.data;
  bot.answerCallbackQuery(query.id);

  // –ü–æ–∫—É–ø–∫–∞
  if (data === 'buy') {
    const msg = `üìã *–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ–∫—É–ø–∫–∏:*

–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –≤—ã –≤–≤–µ–¥—ë—Ç–µ –ª–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å Spotify –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.

‚è± –ü–æ–¥–ø–∏—Å–∫–∞ –¥–ª–∏—Ç—Å—è *1 –º–µ—Å—è—Ü*

‚ö†Ô∏è –ì–ª–∞–≤–Ω–æ–µ ‚Äî –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Å–µ–º–µ–π–Ω–æ–º –ø–ª–∞–Ω–µ!`;
    const kb = {
      inline_keyboard: [
        [{ text: 'üí≥ –û–ø–ª–∞—Ç–∏—Ç—å 169 —Ä—É–±–ª–µ–π (–°–ë–ü)', callback_data: 'pay' }],
        [{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]
      ]
    };
    return bot.sendMessage(chatId, msg, { parse_mode: 'Markdown', reply_markup: kb });
  }

  // ---------- –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ (–°–ë–ü) ----------
  if (data === 'pay') {
    const loading = await bot.sendMessage(chatId, '‚è≥ –°–æ–∑–¥–∞—é —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ –°–ë–ü...');
    const crypto = require('crypto');
    const localId = crypto.randomUUID();
    const ENDPOINTS = [
      'https://api.platega.io/transaction/process',
      'https://app.platega.io/api/transaction/process'
    ];
    const LOGFILE = path.join(__dirname, 'logs', 'platega.log');
    const appendLog = t => {
      try {
        fs.mkdirSync(path.join(__dirname, 'logs'), { recursive: true });
        fs.appendFileSync(LOGFILE, `[${new Date().toISOString()}] ${t}\n`);
      } catch {}
    };

    async function getTransactionDetails(id) {
      const bases = ['https://api.platega.io', 'https://app.platega.io/api', 'https://app.platega.io'];
      for (const base of bases) {
        const url = `${base.replace(/\/$/, '')}/transaction/${id}`;
        try {
          const r = await axios.get(url, {
            headers: { 'X-MerchantId': PLATEGA_SHOP_ID, 'X-Secret': PLATEGA_API_KEY },
            timeout: 10000
          });
          appendLog(`GET ${url} => ${r.status} ${JSON.stringify(r.data)}`);
          if (r.data?.redirect || r.data?.redirectUrl || r.data?.payformSuccessUrl)
            return r.data.redirect || r.data.redirectUrl || r.data.payformSuccessUrl;
        } catch (e) {
          appendLog(`ERR GET ${url} => ${e.response?.status || ''} ${JSON.stringify(e.response?.data || e.message)}`);
        }
      }
      return null;
    }

    try {
      const body = {
        id: localId,
        merchantId: PLATEGA_SHOP_ID,
        paymentMethod: 2,
        paymentDetails: { amount: 169, currency: 'RUB' },
        description: '–ü–æ–¥–ø–∏—Å–∫–∞ Spotify - 1 –º–µ—Å—è—Ü',
        return: 'https://t.me/blesk_spotify_bot',
        failedUrl: 'https://t.me/blesk_spotify_bot',
        payload: JSON.stringify({ chatId })
      };
      const headers = {
        'X-MerchantId': PLATEGA_SHOP_ID,
        'X-Secret': PLATEGA_API_KEY,
        'Content-Type': 'application/json'
      };

      let redirectUrl = null;
      let transactionId = null;
      let raw = null;

      for (const endpoint of ENDPOINTS) {
        try {
          const res = await axios.post(endpoint, body, { headers, timeout: 15000 });
          appendLog(`POST ${endpoint} => ${res.status} ${JSON.stringify(res.data)}`);
          raw = res.data;
          redirectUrl =
            res.data?.redirect ||
            res.data?.redirectUrl ||
            res.data?.payformSuccessUrl ||
            res.data?.transaction?.redirectUrl ||
            null;
          transactionId = res.data?.transactionId || res.data?.id || res.data?.transaction?.id || null;
          if (redirectUrl) break;
        } catch (e) {
          appendLog(`ERR POST ${endpoint} => ${e.response?.status || ''} ${JSON.stringify(e.response?.data || e.message)}`);
        }
      }

      if (!redirectUrl && transactionId) {
        appendLog(`redirect –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–±—É—é GET /transaction/${transactionId}`);
        redirectUrl = await getTransactionDetails(transactionId);
      }

      if (!redirectUrl) {
        await bot.editMessageText('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ –°–ë–ü. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', {
          chat_id: chatId,
          message_id: loading.message_id
        });
        await bot.sendMessage(ADMIN_ID, `‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –°–ë–ü —Å—Å—ã–ª–∫–∏ –¥–ª—è ${chatId}. –ü—Ä–æ–≤–µ—Ä—å logs/platega.log`);
        return;
      }

      dataStore.payments[localId] = {
        chatId,
        amount: 169,
        method: 'SBP',
        status: 'pending',
        created: Date.now(),
        localId,
        remoteId: transactionId,
        rawCreateResponse: raw
      };
      if (transactionId) dataStore.payments[transactionId] = dataStore.payments[localId];
      saveData(dataStore);

      await bot.deleteMessage(chatId, loading.message_id).catch(() => {});
      const kb = {
        inline_keyboard: [
          [{ text: 'üí≥ –û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ –°–ë–ü', url: redirectUrl }],
          [{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]
        ]
      };
      return bot.sendMessage(chatId, '‚úÖ –°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ –°–ë–ü —Å–æ–∑–¥–∞–Ω–∞!', { reply_markup: kb });
    } catch (e) {
      appendLog(`FATAL error SBP create: ${e.stack}`);
      await bot.deleteMessage(chatId, loading.message_id).catch(() => {});
      await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–ø–ª–∞—Ç—ã —á–µ—Ä–µ–∑ –°–ë–ü. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
      await bot.sendMessage(ADMIN_ID, `–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –°–ë–ü –ø–ª–∞—Ç–µ–∂–∞ –¥–ª—è ${chatId}: ${e.message}`);
    }
  }

  // –°–∞–ø–ø–æ—Ä—Ç / FAQ
  if (data === 'support') {
    return bot.sendMessage(chatId, 'üí¨ –°–∞–ø–ø–æ—Ä—Ç: @chanceofrain', {
      reply_markup: { inline_keyboard: [[{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]] }
    });
  } else if (data === 'faq') {
    const msg = `‚ùì *FAQ*\n
*–ß—Ç–æ –¥–µ–ª–∞—Ç—å, –µ—Å–ª–∏ –±—ã–ª –≤ —Å–µ–º–µ–π–Ω–æ–º –ø–ª–∞–Ω–µ?* ‚Äî –ù–∞–ø–∏—à–∏ —Å–∞–ø–ø–æ—Ä—Ç—É.\n
*–°–∫–æ–ª—å–∫–æ –∂–¥–∞—Ç—å?* ‚Äî 5‚Äì10 –º–∏–Ω—É—Ç, –º–∞–∫—Å–∏–º—É–º –ø–æ–ª—á–∞—Å–∞.`;
    return bot.sendMessage(chatId, msg, {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: [[{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]] }
    });
  } else if (data === 'menu') {
    sendMainMenu(chatId);
  } else if (data.startsWith('complete_')) {
    if (chatId.toString() !== ADMIN_ID) return bot.sendMessage(chatId, '‚ùå –ù–µ—Ç –ø—Ä–∞–≤');
    const userId = data.replace('complete_', '');
    await bot.sendMessage(userId, '‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞! –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è üéµ');
    bot.sendMessage(chatId, `‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${userId}`);
  }
});

// ---------- –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–≥–∏–Ω–∞/–ø–∞—Ä–æ–ª—è ----------
bot.on('message', async msg => {
  const chatId = msg.chat.id;
  const text = msg.text;
  if (text && text.startsWith('/')) return;
  if (userStates[chatId]) {
    if (userStates[chatId].step === 'awaiting_login') {
      userStates[chatId].login = text;
      userStates[chatId].step = 'awaiting_password';
      return bot.sendMessage(chatId, 'üîê –í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å Spotify:');
    } else if (userStates[chatId].step === 'awaiting_password') {
      const login = userStates[chatId].login;
      const password = text;
      const contact = msg.from.username
        ? `@${msg.from.username}`
        : `${msg.from.first_name || ''} ${msg.from.last_name || ''}`.trim();
      const adminMsg = `üÜï *–ù–æ–≤–∞—è –æ–ø–ª–∞—Ç–∞*\nüë§ ${contact}\nüÜî ${chatId}\nüìß \`${login}\`\nüîê \`${password}\``;
      const kb = { inline_keyboard: [[{ text: '‚úÖ –ì–æ—Ç–æ–≤–æ', callback_data: `complete_${chatId}` }]] };
      await bot.sendMessage(ADMIN_ID, adminMsg, { parse_mode: 'Markdown', reply_markup: kb });
      await bot.sendMessage(chatId, '‚úÖ –î–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–π–º—ë—Ç –¥–æ 30 –º–∏–Ω—É—Ç.');
      delete userStates[chatId];
    }
  }
});

// ---------- CALLBACK –ø–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Platega ----------
app.post('/webhook/platega', async (req, res) => {
  try {
    const headers = Object.fromEntries(Object.entries(req.headers).map(([k, v]) => [k.toLowerCase(), v]));
    const merchant = headers['x-merchantid'] || headers['x-merchant-id'];
    const secret = headers['x-secret'] || headers['x-secret-key'];
    if (!merchant || !secret || merchant !== PLATEGA_SHOP_ID || secret !== PLATEGA_API_KEY) {
      console.error('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ webhook:', headers);
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const body = req.body || {};
    console.log('üì¶ Webhook Platega:', JSON.stringify(body, null, 2));
    const status = (body.status || body.transaction?.status || '').toUpperCase();
    const txId = body.id || body.transaction?.id || body.transactionId || null;
    let chatId = null;

    const payloadRaw = body.payload || body.transaction?.payload;
    if (payloadRaw) {
      try {
        if (typeof payloadRaw === 'string') {
          const parsed = JSON.parse(payloadRaw);
          if (parsed.chatId) chatId = parsed.chatId;
        } else if (typeof payloadRaw === 'object' && payloadRaw.chatId) chatId = payloadRaw.chatId;
      } catch {}
    }
    if (!chatId && txId && dataStore.payments[txId]) chatId = dataStore.payments[txId].chatId;

    console.log('Webhook status:', status, 'txId:', txId, 'chatId:', chatId);

    if (status === 'CONFIRMED') {
      if (chatId) {
        dataStore.payments[txId] = dataStore.payments[txId] || {};
        dataStore.payments[txId].status = 'paid';
        saveData(dataStore);
        userStates[chatId] = { step: 'awaiting_login', transactionId: txId };
        await bot.sendMessage(chatId, '‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞! –í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω Spotify:');
      } else {
        await bot.sendMessage(ADMIN_ID, `‚ö†Ô∏è Webhook CONFIRMED, chatId –Ω–µ –Ω–∞–π–¥–µ–Ω\n${JSON.stringify(body)}`);
      }
    } else if (['CANCELED', 'FAILED', 'EXPIRED'].includes(status)) {
      if (chatId) await bot.sendMessage(chatId, `‚ùå –ü–ª–∞—Ç—ë–∂ –Ω–µ –ø—Ä–æ—à—ë–ª (${status}).`);
    } else {
      console.log('‚ÑπÔ∏è –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —Å—Ç–∞—Ç—É—Å webhook:', status);
    }

    res.status(200).json({ ok: true });
  } catch (err) {
    console.error('üî• –û—à–∏–±–∫–∞ webhook Platega:', err);
    await bot.sendMessage(ADMIN_ID, `–û—à–∏–±–∫–∞ webhook Platega: ${err.message}`);
    res.status(200).json({ ok: true });
  }
});

// ---------- –°–µ—Ä–≤–µ—Ä ----------
app.get('/', (req, res) => res.send('Blesk Spotify Bot is running.'));
app.listen(PORT, '0.0.0.0', () => console.log(`‚úÖ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`));
