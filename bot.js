require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const express = require('express');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

const BOT_TOKEN = process.env.BOT_TOKEN;
const ADMIN_ID = process.env.ADMIN_ID;
const PLATEGA_API_KEY = process.env.PLATEGA_API_KEY;
const PLATEGA_SHOP_ID = process.env.PLATEGA_SHOP_ID;
const PORT = process.env.PORT || 5000;

if (!BOT_TOKEN || !ADMIN_ID || !PLATEGA_API_KEY || !PLATEGA_SHOP_ID) {
  console.error('‚ùå –ù–µ –∑–∞–¥–∞–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è (.env)');
  process.exit(1);
}

const bot = new TelegramBot(BOT_TOKEN, { polling: true });
const app = express();
app.use(express.json({ limit: '200kb' }));

const DATA_FILE = path.join(__dirname, 'data.json');
function loadData() {
  if (fs.existsSync(DATA_FILE)) {
    try {
      return JSON.parse(fs.readFileSync(DATA_FILE, 'utf8'));
    } catch {
      return { payments: {}, users: {} };
    }
  }
  return { payments: {}, users: {} };
}
function saveData(data) {
  try {
    fs.writeFileSync(DATA_FILE, JSON.stringify(data, null, 2));
  } catch (e) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ data.json:', e.message);
  }
}
let dataStore = loadData();
const userStates = {};

const IMAGES = {
  MAIN: './attached_assets/pick spt_1759573098998.jpg',
  HELP: './attached_assets/pick help (1)_1759573098998.jpg',
  FAQ: './attached_assets/picksher_1759573098998.jpg'
};

// ---------- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ----------
function sendMainMenu(chatId) {
  const msg = `‚ùáÔ∏è *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Blesk !* ‚ùáÔ∏è

*‚ùóÔ∏è–í–ê–ñ–ù–û‚ùóÔ∏è*
–ü–µ—Ä–µ–¥ –ø–æ–∫—É–ø–∫–æ–π —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç Spotify –Ω–µ —Å–æ—Å—Ç–æ—è–ª –≤ —Å–µ–º–µ–π–Ω–æ–º –ø–ª–∞–Ω–µ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π –≥–æ–¥.
–ï—Å–ª–∏ –Ω–µ —É–≤–µ—Ä–µ–Ω—ã ‚Äî –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Å–∞–ø–ø–æ—Ä—Ç!`;
  const keyboard = {
    inline_keyboard: [
      [{ text: 'üí≥ –ö—É–ø–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É (169 —Ä—É–±–ª–µ–π)', callback_data: 'buy' }],
      [{ text: 'üí¨ –°–∞–ø–ø–æ—Ä—Ç', callback_data: 'support' }],
      [{ text: '‚ùì FAQ', callback_data: 'faq' }]
    ]
  };
  if (fs.existsSync(IMAGES.MAIN))
    bot.sendPhoto(chatId, IMAGES.MAIN, { caption: msg, parse_mode: 'Markdown', reply_markup: keyboard });
  else bot.sendMessage(chatId, msg, { parse_mode: 'Markdown', reply_markup: keyboard });
}

bot.onText(/\/start/, msg => sendMainMenu(msg.chat.id));

// ---------- Callback –∫–Ω–æ–ø–∫–∏ ----------
bot.on('callback_query', async query => {
  const chatId = query.message.chat.id;
  const data = query.data;
  bot.answerCallbackQuery(query.id);

  // –ü–æ–∫—É–ø–∫–∞
  if (data === 'buy') {
    const msg = `üìã *–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ –ø–æ–∫—É–ø–∫–∏:*

–ü–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –≤—ã –≤–≤–µ–¥—ë—Ç–µ –ª–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å Spotify –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è.

‚è± –ü–æ–¥–ø–∏—Å–∫–∞ –¥–ª–∏—Ç—Å—è *1 –º–µ—Å—è—Ü*

‚ö†Ô∏è –ì–ª–∞–≤–Ω–æ–µ ‚Äî –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Å–µ–º–µ–π–Ω–æ–º –ø–ª–∞–Ω–µ!`;
    const kb = {
      inline_keyboard: [
        [{ text: 'üí≥ –û–ø–ª–∞—Ç–∏—Ç—å 169 —Ä—É–±–ª–µ–π (–°–ë–ü)', callback_data: 'pay' }],
        [{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]
      ]
    };
    return bot.sendMessage(chatId, msg, { parse_mode: 'Markdown', reply_markup: kb });
  }

  // ---------- –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞ —á–µ—Ä–µ–∑ –°–ë–ü ----------
  if (data === 'pay') {
    const loading = await bot.sendMessage(chatId, '‚è≥ –°–æ–∑–¥–∞—é —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ –°–ë–ü...');

    const crypto = require('crypto');
    const localId = crypto.randomUUID();
    const ENDPOINTS = [
      'https://api.platega.io/transaction/process',
      'https://app.platega.io/api/transaction/process',
      'https://app.platega.io/transaction/process'
    ];
    const LOGFILE = path.join(__dirname, 'logs', 'platega.log');

    const appendLog = t => {
      try {
        fs.mkdirSync(path.join(__dirname, 'logs'), { recursive: true });
        fs.appendFileSync(LOGFILE, `[${new Date().toISOString()}] ${t}\n`);
      } catch {}
    };

    async function getTransactionDetails(id) {
      const bases = ['https://api.platega.io', 'https://app.platega.io/api', 'https://app.platega.io'];
      for (const base of bases) {
        const url = `${base.replace(/\/$/, '')}/transaction/${id}`;
        try {
          const r = await axios.get(url, {
            headers: { 'X-MerchantId': PLATEGA_SHOP_ID, 'X-Secret': PLATEGA_API_KEY },
            timeout: 10000
          });
          appendLog(`GET ${url} => ${r.status} ${JSON.stringify(r.data)}`);
          if (r.data?.redirect || r.data?.redirectUrl || r.data?.payformSuccessUrl)
            return r.data.redirect || r.data.redirectUrl || r.data.payformSuccessUrl;
        } catch (e) {
          appendLog(`ERR GET ${url} => ${e.response?.status || ''} ${JSON.stringify(e.response?.data || e.message)}`);
        }
      }
      return null;
    }

    try {
      const body = {
        id: localId,
        merchantId: PLATEGA_SHOP_ID,
        paymentMethod: 2,
        paymentDetails: { amount: 169, currency: 'RUB' },
        description: '–ü–æ–¥–ø–∏—Å–∫–∞ Spotify - 1 –º–µ—Å—è—Ü',
        return: 'https://t.me/blesk_spotify_bot',
        failedUrl: 'https://t.me/blesk_spotify_bot',
        payload: JSON.stringify({ chatId })
      };
      const headers = {
        'X-MerchantId': PLATEGA_SHOP_ID,
        'X-Secret': PLATEGA_API_KEY,
        'Content-Type': 'application/json'
      };

      let redirectUrl = null;
      let transactionId = null;
      let raw = null;

      for (const endpoint of ENDPOINTS) {
        try {
          const res = await axios.post(endpoint, body, { headers, timeout: 15000 });
          appendLog(`POST ${endpoint} => ${res.status} ${JSON.stringify(res.data)}`);
          raw = res.data;
          redirectUrl =
            res.data?.redirect ||
            res.data?.redirectUrl ||
            res.data?.payformSuccessUrl ||
            res.data?.transaction?.redirectUrl ||
            null;
          transactionId = res.data?.transactionId || res.data?.id || res.data?.transaction?.id || null;
          if (redirectUrl) break;
        } catch (e) {
          appendLog(`ERR POST ${endpoint} => ${e.response?.status || ''} ${JSON.stringify(e.response?.data || e.message)}`);
        }
      }

      if (!redirectUrl && transactionId) {
        appendLog(`redirect –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–±—É—é GET /transaction/${transactionId}`);
        redirectUrl = await getTransactionDetails(transactionId);
      }

      if (!redirectUrl) {
        await bot.editMessageText('‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ –°–ë–ü. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.', {
          chat_id: chatId,
          message_id: loading.message_id
        });
        await bot.sendMessage(ADMIN_ID, `‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –°–ë–ü —Å—Å—ã–ª–∫–∏ –¥–ª—è ${chatId}. –ü—Ä–æ–≤–µ—Ä—å logs/platega.log`);
        return;
      }

      dataStore.payments[localId] = {
        chatId,
        amount: 169,
        method: 'SBP',
        status: 'pending',
        created: Date.now(),
        localId,
        remoteId: transactionId,
        rawCreateResponse: raw
      };
      if (transactionId) dataStore.payments[transactionId] = dataStore.payments[localId];
      saveData(dataStore);

      await bot.deleteMessage(chatId, loading.message_id).catch(() => {});
      const kb = {
        inline_keyboard: [
          [{ text: 'üí≥ –û–ø–ª–∞—Ç–∏—Ç—å —á–µ—Ä–µ–∑ –°–ë–ü', url: redirectUrl }],
          [{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]
        ]
      };
      return bot.sendMessage(chatId, '‚úÖ –°—Å—ã–ª–∫–∞ –Ω–∞ –æ–ø–ª–∞—Ç—É —á–µ—Ä–µ–∑ –°–ë–ü —Å–æ–∑–¥–∞–Ω–∞!', { reply_markup: kb });
    } catch (e) {
      appendLog(`FATAL error SBP create: ${e.stack}`);
      await bot.deleteMessage(chatId, loading.message_id).catch(() => {});
      await bot.sendMessage(chatId, '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –æ–ø–ª–∞—Ç—ã —á–µ—Ä–µ–∑ –°–ë–ü. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
      await bot.sendMessage(ADMIN_ID, `–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –°–ë–ü –ø–ª–∞—Ç–µ–∂–∞ –¥–ª—è ${chatId}: ${e.message}`);
    }
  }

  // ---------- FAQ / Support ----------
  if (data === 'support') {
    const msg = `üí¨ *–°–∞–ø–ø–æ—Ä—Ç*\n\n@chanceofrain ‚Äî –ø–æ –≤—Å–µ–º –≤–æ–ø—Ä–æ—Å–∞–º.`;
    const kb = { inline_keyboard: [[{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]] };
    if (fs.existsSync(IMAGES.HELP))
      bot.sendPhoto(chatId, IMAGES.HELP, { caption: msg, parse_mode: 'Markdown', reply_markup: kb });
    else bot.sendMessage(chatId, msg, { parse_mode: 'Markdown', reply_markup: kb });
  } else if (data === 'faq') {
    const msg = `‚ùì *FAQ*\n
*–í–æ–ø—Ä–æ—Å:* –ß—Ç–æ –¥–µ–ª–∞—Ç—å, –µ—Å–ª–∏ —É–∂–µ –±—ã–ª –≤ —Å–µ–º–µ–π–Ω–æ–º –ø–ª–∞–Ω–µ?
*–û—Ç–≤–µ—Ç:* –ù–∞–ø–∏—à–∏—Ç–µ —Å–∞–ø–ø–æ—Ä—Ç—É, –º—ã —Ä–µ—à–∏–º –≤–æ–ø—Ä–æ—Å.\n
*–í–æ–ø—Ä–æ—Å:* –°–∫–æ–ª—å–∫–æ –∂–¥–∞—Ç—å?
*–û—Ç–≤–µ—Ç:* –û–±—ã—á–Ω–æ 5‚Äì10 –º–∏–Ω—É—Ç, –º–∞–∫—Å–∏–º—É–º –ø–æ–ª—á–∞—Å–∞.`;
    const kb = { inline_keyboard: [[{ text: 'üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é', callback_data: 'menu' }]] };
    if (fs.existsSync(IMAGES.FAQ))
      bot.sendPhoto(chatId, IMAGES.FAQ, { caption: msg, parse_mode: 'Markdown', reply_markup: kb });
    else bot.sendMessage(chatId, msg, { parse_mode: 'Markdown', reply_markup: kb });
  } else if (data === 'menu') {
    sendMainMenu(chatId);
  } else if (data.startsWith('complete_')) {
    if (chatId.toString() !== ADMIN_ID)
      return bot.sendMessage(chatId, '‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è');
    const userId = data.replace('complete_', '');
    await bot.sendMessage(
      userId,
      '‚úÖ *–í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!* –ü—Ä–∏—è—Ç–Ω–æ–≥–æ –ø—Ä–æ—Å–ª—É—à–∏–≤–∞–Ω–∏—è üéµ',
      { parse_mode: 'Markdown' }
    );
    bot.sendMessage(chatId, `‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é ${userId}`);
  }
});

// ---------- –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–≥–∏–Ω–∞/–ø–∞—Ä–æ–ª—è ----------
bot.on('message', async msg => {
  const chatId = msg.chat.id;
  const text = msg.text;
  if (text && text.startsWith('/')) return;

  if (userStates[chatId]) {
    if (userStates[chatId].step === 'awaiting_login') {
      userStates[chatId].login = text;
      userStates[chatId].step = 'awaiting_password';
      return bot.sendMessage(chatId, 'üîê –í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –æ—Ç Spotify:');
    } else if (userStates[chatId].step === 'awaiting_password') {
      const login = userStates[chatId].login;
      const password = text;
      const user = msg.from;
      const contact = user.username ? `@${user.username}` : `${user.first_name || ''} ${user.last_name || ''}`.trim();
      const adminMsg = `üÜï *–ù–æ–≤–∞—è –æ–ø–ª–∞—Ç–∞*\nüë§ ${contact}\nüÜî ${chatId}\nüìß \`${login}\`\nüîê \`${password}\``;
      const kb = { inline_keyboard: [[{ text: '‚úÖ –ì–æ—Ç–æ–≤–æ', callback_data: `complete_${chatId}` }]] };
      await bot.sendMessage(ADMIN_ID, adminMsg, { parse_mode: 'Markdown', reply_markup: kb });
      await bot.sendMessage(chatId, '‚úÖ –î–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–µ–Ω—ã. –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–π–º—ë—Ç –¥–æ 30 –º–∏–Ω—É—Ç.');
      delete userStates[chatId];
    }
  }
});

// ---------- Webhook Platega ----------
app.post('/webhook/platega', async (req, res) => {
  try {
    const h = req.headers || {};
    const m = h['x-merchantid'] || h['x-merchant-id'];
    const s = h['x-secret'];
    if (m !== PLATEGA_SHOP_ID || s !== PLATEGA_API_KEY) return res.status(401).json({ error: 'Unauthorized' });

    const b = req.body;
    const status = (b.status || b.transaction?.status || '').toUpperCase();
    const txId = b.id || b.transaction?.id || b.transactionId || null;
    const payloadRaw = b.payload || b.transaction?.payload;
    let chatId = null;
    try {
      if (payloadRaw) chatId = JSON.parse(payloadRaw).chatId;
    } catch {}
    if (!chatId && txId && dataStore.payments[txId]) chatId = dataStore.payments[txId].chatId;

    if (status === 'CONFIRMED' && chatId) {
      dataStore.payments[txId] = dataStore.payments[txId] || {};
      dataStore.payments[txId].status = 'paid';
      saveData(dataStore);
      userStates[chatId] = { step: 'awaiting_login', transactionId: txId };
      await bot.sendMessage(chatId, '‚úÖ –û–ø–ª–∞—Ç–∞ –ø–æ–ª—É—á–µ–Ω–∞!\nüìù –í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω Spotify:');
    } else if (status === 'CANCELED' && chatId)
      await bot.sendMessage(chatId, '‚ùå –ü–ª–∞—Ç—ë–∂ –æ—Ç–º–µ–Ω—ë–Ω. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
    res.status(200).json({ ok: true });
  } catch (e) {
    console.error('Webhook error:', e);
    res.status(200).json({ ok: true });
  }
});

app.get('/', (req, res) => res.send('Blesk Spotify Bot is running.'));
app.listen(PORT, '0.0.0.0', () => console.log(`‚úÖ –°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É ${PORT}`));
